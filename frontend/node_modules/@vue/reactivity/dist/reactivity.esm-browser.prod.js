function t(t,e){const n=Object.create(null),r=t.split(",");for(let t=0;t<r.length;t++)n[r[t]]=!0;return e?t=>!!n[t.toLowerCase()]:t=>!!n[t]}const e={},n=()=>{},r=Object.prototype.hasOwnProperty,o=(t,e)=>r.call(t,e),c=Array.isArray,u=t=>"symbol"==typeof t,s=t=>null!==t&&"object"==typeof t,l=Object.prototype.toString,a=t=>(t=>l.call(t))(t).slice(8,-1),i=(t,e)=>t!==e&&(t==t||e==e),f=new WeakMap,d=[];let h;const p=Symbol(""),g=Symbol("");function v(t,n=e){(function(t){return t&&!0===t._isEffect})(t)&&(t=t.raw);const r=function(t,e){const n=function(...r){if(!n.active)return e.scheduler?void 0:t(...r);if(!d.includes(n)){S(n);try{return M(),d.push(n),h=n,t(...r)}finally{d.pop(),k(),h=d[d.length-1]}}};return n.id=w++,n._isEffect=!0,n.active=!0,n.raw=t,n.deps=[],n.options=e,n}(t,n);return n.lazy||r(),r}function y(t){t.active&&(S(t),t.options.onStop&&t.options.onStop(),t.active=!1)}let w=0;function S(t){const{deps:e}=t;if(e.length){for(let n=0;n<e.length;n++)e[n].delete(t);e.length=0}}let b=!0;const R=[];function m(){R.push(b),b=!1}function M(){R.push(b),b=!0}function k(){const t=R.pop();b=void 0===t||t}function E(t,e,n){if(!b||void 0===h)return;let r=f.get(t);r||f.set(t,r=new Map);let o=r.get(n);o||r.set(n,o=new Set),o.has(h)||(o.add(h),h.deps.push(o))}function O(t,e,n,r,o,u){const s=f.get(t);if(!s)return;const l=new Set,a=new Set,i=t=>{t&&t.forEach(t=>{t===h&&b||(t.options.computed?a.add(t):l.add(t))})};if("clear"===e)s.forEach(i);else if("length"===n&&c(t))s.forEach((t,e)=>{("length"===e||e>=r)&&i(t)});else{void 0!==n&&i(s.get(n));const r="add"===e||"delete"===e&&!c(t);(r||"set"===e&&t instanceof Map)&&i(s.get(c(t)?"length":p)),r&&t instanceof Map&&i(s.get(g))}const d=t=>{t.options.scheduler?t.options.scheduler(t):t()};a.forEach(d),l.forEach(d)}const W=new Set(Object.getOwnPropertyNames(Symbol).map(t=>Symbol[t]).filter(u)),_=A(),j=A(!1,!0),z=A(!0),P=A(!0,!0),x={};function A(t=!1,e=!1){return function(n,r,l){const a=c(n);if(a&&o(x,r))return Reflect.get(x,r,l);const i=Reflect.get(n,r,l);return u(r)&&W.has(r)?i:e?(!t&&E(n,0,r),i):Rt(i)?a?(!t&&E(n,0,r),i):i.value:(!t&&E(n,0,r),s(i)?t?dt(i):it(i):i)}}["includes","indexOf","lastIndexOf"].forEach(t=>{x[t]=function(...e){const n=wt(this);for(let t=0,e=this.length;t<e;t++)E(n,0,t+"");const r=n[t](...e);return-1===r||!1===r?n[t](...e.map(wt)):r}});const K=C(),N=C(!0);function C(t=!1){return function(e,n,r,u){const s=e[n];if(!t&&(r=wt(r),!c(e)&&Rt(s)&&!Rt(r)))return s.value=r,!0;const l=o(e,n),a=Reflect.set(e,n,r,u);return e===wt(u)&&(l?i(r,s)&&O(e,"set",n,r):O(e,"add",n,r)),a}}function F(t,e){const n=Reflect.has(t,e);return E(t,0,e),n}function I(t){return E(t,0,p),Reflect.ownKeys(t)}const L={get:_,set:K,deleteProperty:function(t,e){const n=o(t,e),r=Reflect.deleteProperty(t,e);return r&&n&&O(t,"delete",e,void 0),r},has:F,ownKeys:I},V={get:z,has:F,ownKeys:I,set:(t,e)=>!0,deleteProperty:(t,e)=>!0},q={...L,get:j,set:N},B={...V,get:P},D=t=>s(t)?it(t):t,G=t=>s(t)?dt(t):t,H=t=>Reflect.getPrototypeOf(t);function J(t,e,n){t=wt(t);const r=wt(e);e!==r&&E(t,0,e),E(t,0,r);const{has:o,get:c}=H(t);return o.call(t,e)?n(c.call(t,e)):o.call(t,r)?n(c.call(t,r)):void 0}function Q(t){const e=wt(this),n=wt(t);t!==n&&E(e,0,t),E(e,0,n);const r=H(e).has;return r.call(e,t)||r.call(e,n)}function T(t){return E(t=wt(t),0,p),Reflect.get(H(t),"size",t)}function U(t){return function(e,n){const r=this,o=wt(r),c=t?G:D;return!t&&E(o,0,p),H(o).forEach.call(o,(function(t,n){return e.call(r,c(t),c(n),r)}),n)}}function X(t,e){return function(...n){const r=wt(this),o=r instanceof Map,c="entries"===t||t===Symbol.iterator&&o,u="keys"===t&&o,s=H(r)[t].apply(r,n),l=e?G:D;return!e&&E(r,0,u?g:p),{next(){const{value:t,done:e}=s.next();return e?{value:t,done:e}:{value:c?[l(t[0]),l(t[1])]:l(t),done:e}},[Symbol.iterator](){return this}}}}function Y(t){return function(...e){return"delete"!==t&&this}}const Z={get(t){return J(this,t,D)},get size(){return T(this)},has:Q,add:function(t){t=wt(t);const e=wt(this),n=H(e),r=n.has.call(e,t),o=n.add.call(e,t);return r||O(e,"add",t,t),o},set:function(t,e){e=wt(e);const n=wt(this),{has:r,get:o,set:c}=H(n);let u=r.call(n,t);u||(t=wt(t),u=r.call(n,t));const s=o.call(n,t),l=c.call(n,t,e);return u?i(e,s)&&O(n,"set",t,e):O(n,"add",t,e),l},delete:function(t){const e=wt(this),{has:n,get:r,delete:o}=H(e);let c=n.call(e,t);c||(t=wt(t),c=n.call(e,t)),r&&r.call(e,t);const u=o.call(e,t);return c&&O(e,"delete",t,void 0),u},clear:function(){const t=wt(this),e=0!==t.size,n=H(t).clear.call(t);return e&&O(t,"clear",void 0,void 0),n},forEach:U(!1)},$={get(t){return J(this,t,G)},get size(){return T(this)},has:Q,add:Y("add"),set:Y("set"),delete:Y("delete"),clear:Y("clear"),forEach:U(!0)};function tt(t){return(e,n,r)=>Reflect.get(o(t,n)&&n in e?t:e,n,r)}["keys","values","entries",Symbol.iterator].forEach(t=>{Z[t]=X(t,!1),$[t]=X(t,!0)});const et={get:tt(Z)},nt={get:tt($)},rt=new WeakMap,ot=new WeakMap,ct=new WeakMap,ut=new WeakMap,st=new WeakSet,lt=new Set([Set,Map,WeakMap,WeakSet]),at=t("Object,Array,Map,Set,WeakMap,WeakSet");function it(t){return ut.has(t)?t:pt(t,rt,ot,L,et)}function ft(t){return pt(t,rt,ot,q,et)}function dt(t){return pt(t,ct,ut,V,nt)}function ht(t){return pt(t,ct,ut,B,nt)}function pt(t,e,n,r,o){if(!s(t))return t;let c=e.get(t);if(void 0!==c)return c;if(n.has(t))return t;if((u=t)._isVNode||!at(a(u))||st.has(u)||Object.isFrozen(u))return t;var u;const l=lt.has(t.constructor)?o:r;return c=new Proxy(t,l),e.set(t,c),n.set(c,t),c}function gt(t){return t=ut.get(t)||t,ot.has(t)}function vt(t){return ut.has(t)}function yt(t){return ut.has(t)||ot.has(t)}function wt(t){return t=ut.get(t)||t,ot.get(t)||t}function St(t){return st.add(t),t}const bt=t=>s(t)?it(t):t;function Rt(t){return!!t&&!0===t._isRef}function mt(t){return kt(t)}function Mt(t){return kt(t,!0)}function kt(t,e=!1){if(Rt(t))return t;let n=e?t:bt(t);const r={_isRef:!0,get value(){return E(r,0,"value"),n},set value(o){i(wt(o),t)&&(t=o,n=e?o:bt(o),O(r,"set","value",void 0))}};return r}function Et(t){O(t,"set","value",void 0)}function Ot(t){return Rt(t)?t.value:t}function Wt(t){const{get:e,set:n}=t(()=>E(r,0,"value"),()=>O(r,"set","value")),r={_isRef:!0,get value(){return e()},set value(t){n(t)}};return r}function _t(t){const e={};for(const n in t)e[n]=jt(t,n);return e}function jt(t,e){return{_isRef:!0,get value(){return t[e]},set value(n){t[e]=n}}}function zt(t){let e,r;"function"==typeof t?(e=t,r=n):(e=t.get,r=t.set);let o,c,u=!0;const s=v(e,{lazy:!0,computed:!0,scheduler:()=>{u||(u=!0,O(c,"set","value"))}});return c={_isRef:!0,effect:s,get value(){return u&&(o=s(),u=!1),E(c,0,"value"),o},set value(t){r(t)}},c}export{p as ITERATE_KEY,zt as computed,Wt as customRef,v as effect,M as enableTracking,yt as isProxy,gt as isReactive,vt as isReadonly,Rt as isRef,St as markRaw,m as pauseTracking,it as reactive,dt as readonly,mt as ref,k as resetTracking,ft as shallowReactive,ht as shallowReadonly,Mt as shallowRef,y as stop,wt as toRaw,jt as toRef,_t as toRefs,E as track,O as trigger,Et as triggerRef,Ot as unref};
